/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package graph;

import java.util.*;

public class Graph<E> {
    private Map<Node, Set<Node>> vertices;

    /**
     * Constructor
     */
    public Graph() {
        vertices =  new HashMap<>();
    }

    /**
     * Add new node
     * will return null if input value is null or empty
     * @param value E data of new Node
     * @return Node inserted
     */
    public Node addNode(E value) {
        Node newNode;
        if(value != null) {
            newNode = new Node<>(value);
            vertices.putIfAbsent(newNode, new HashSet<>());
            return newNode;
        }
        return null;
    }

    /**
     * Adds Edge to to and from Nodes if they exist
     * @param to Node, destination Node
     * @param from Node, source Node
     * @param weight int, Edge weight
     */
    public void addEdge(Node to, Node from, int weight) {

        if(vertices.containsKey(to) && vertices.containsKey(from)) {
            Edge edge = new Edge<>(to, from, weight);

            // add to Set / adjacency list
            // update Node Set of edges
            // update the Vertex with updated Node
            vertices.get(to).add(from);
            to.edges.add(edge);
            vertices.put(to, vertices.get(to));

            vertices.get(from).add(to);
            from.edges.add(edge);
            vertices.put(from, vertices.get(from));
        }
    }

    /**
     * Gets all vertices
     * @return Set of Nodes
     */
    public Set<Node> getNodes() {
        if(vertices != null) {
            return vertices.keySet();
        }
        return null;
    }

    /**
     * Gets all neighbors
     * for a Node
     * @param vertex Node
     * @return Set of Nodes
     */
    public Set<Node> getNeighbors(Node vertex) {
        if(vertices.containsKey(vertex)) {
            return vertices.get(vertex);
        }
        return null;
    }

    /**
     * Getter for size
     * @return int, number of vertices
     */
    public int size() {
        return this.vertices.size();
    }

    /**
     * Breadth first traversal.
     * @param node Node, origin node
     * @return Set, Nodes
     */
    List<Node> bft(Node node) {
        // track seen Nodes
        Set<Node> visited = new HashSet<>();

        // result list to return
        List<Node> bfs = new ArrayList<>();

        // queue for BFS
        Queue<Node> queue = new LinkedList<>();

        if(node == null) {
            throw new IllegalArgumentException("Your input is null");
        }

        if(!vertices.containsKey(node)) {
            throw new IllegalArgumentException("Your input node is not in the graph");
        }

        visited.add(node);
        queue.add(node);
        bfs.add(node);

        while (queue.size() != 0)
        {
            // dequeue a vertex from queue
            // if not in visited set, add to result set
            node = queue.poll();

            if(!visited.contains(node)) {
                bfs.add(node);
            }
            visited.add(node);

            // Get all neighbor vertices of the dequeued Node
            // if a adjacent has not been visited, then put it in
            // visited Set and enqueue it
            vertices.get(node).forEach( neighbor -> {
                if(!visited.contains(neighbor))  queue.add(neighbor);
            });
        }
        return bfs;
    }

    /**
     * Static method that returns boolean and cost
     * if direct path is possible for cities contained in input array
     * and graph input
     * @param cities Node[]
     * @param graph Graph
     * @return String, true with sum of weights or false $0
     */
    public static String get_edge(Node[] cities, Graph graph) {
        int sumWeight = 0;
        String bool = "False, $";

        if(cities == null || graph == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        if(cities.length == 1) {
            return bool + sumWeight;
        }

        Set graphCities = graph.getNodes();

        for(int i = 0; i < cities.length - 1; i++) {
            int weight = 0;

            if(!graphCities.contains(cities[i])) {
                throw new IllegalArgumentException(cities[i].data + " in your input array does not exist in the graph");
            } else {
                if(!graph.getNeighbors(cities[i]).contains(cities[i + 1])) {
                    return bool + "0";
                } else {
                    Set<Edge> toEdges = cities[i].edges;
                    for(Edge edge : toEdges) {
                        if (cities[i].edges.contains(edge) &&
                                (edge.to.equals(cities[i]) && edge.from.equals(cities[i + 1])) ||
                                (edge.to.equals(cities[i + 1]) && edge.from.equals(cities[i]))) {
                            weight = edge.getWeight();
                        }
                    }
                    sumWeight += weight;
                }
            }
        }

        return "True, $" + sumWeight;
    }
}