/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package graph;

import java.util.*;

public class Graph<E> {
    private Map<Node, Set<Node>> vertices;

    /**
     * Constructor
     */
    public Graph() {
        vertices =  new HashMap<>();
    }

    /**
     * Add new node
     * will return null if input value is null or empty
     * @param value E data of new Node
     * @return Node inserted
     */
    public Node addNode(E value) {
        Node newNode;
        if(value != null) {
            newNode = new Node(value);
            vertices.putIfAbsent(newNode, new HashSet<>());
            return newNode;
        }
        return null;
    }

    /**
     * Adds Edge to to and from Nodes if they exist
     * @param to Node, destination Node
     * @param from Node, source Node
     * @param weight int, Edge weight
     */
    public void addEdge(Node to, Node from, int weight) {

        if(vertices.containsKey(to) && vertices.containsKey(from)) {
            Edge edge = new Edge(to, from, weight);

            // add to Set / adjacency list
            // update Node Set of edges
            // update the Vertex with updated Node
            vertices.get(to).add(from);
            to.edges.add(edge);
            vertices.put(to, vertices.get(to));

            vertices.get(from).add(to);
            from.edges.add(edge);
            vertices.put(from, vertices.get(from));
        }
    }

    /**
     * Gets all vertices
     * @return Set of Nodes
     */
    public Set<Node> getNodes() {
        if(vertices != null) {
            return vertices.keySet();
        }
        return null;
    }

    /**
     * Gets all neighbors
     * for a Node
     * @param vertex Node
     * @return Set of Nodes
     */
    public Set<Node> getNeighbors(Node vertex) {
        if(vertices.containsKey(vertex)) {
            return vertices.get(vertex);
        }
        return null;
    }

    /**
     * Getter for size
     * @return int, number of vertices
     */
    public int size() {
        return this.vertices.size();
    }

    /**
     * Inner Node class
     */
    class Node {
        E data;
        Set<Edge> edges;

        Node(E value) {
            this.data = value;
            edges = new HashSet<>();
        }

        @Override
        public String toString() {
            return "Node: " +
                    "data =" + data +
                    ", edges =" + edges +
                    '}';
        }
    }

    /**
     * Inner Edge class
     */
    class Edge {
        int weight;
        Node to;
        Node from;

        /**
         * Constructor
         * @param to Node, destination Node
         * @param from Node, source Node
         * @param weight int, weight
         */
        public Edge(Node to, Node from, int weight) {
            this.to = to;
            this.from = from;
            this.weight = weight;
        }

        @Override
        public String toString() {
            return "Edge: " +
                    "weight = " + weight;
        }
    }


    /**
     * Breadth first traversal.
     * @param node Node, origin node
     * @return Set, Nodes
     */
    List<Node> bft(Node node) {
        // track seen Nodes
        Set<Node> visited = new HashSet<>();

        // result list to return
        List<Node> bfs = new ArrayList<>();

        // queue for BFS
        Queue<Node> queue = new LinkedList<>();

        if(node == null) {
            throw new IllegalArgumentException("Your input is null");
        }

        if(!vertices.containsKey(node)) {
            throw new IllegalArgumentException("Your input node is not in the graph");
        }

        visited.add(node);
        queue.add(node);
        bfs.add(node);

        while (queue.size() != 0)
        {
            // dequeue a vertex from queue
            // if not in visited set, add to result set
            node = queue.poll();

            if(!visited.contains(node)) {
                bfs.add(node);
            }
            visited.add(node);

            // Get all neighbor vertices of the dequeued Node
            // if a adjacent has not been visited, then put it in
            // visited Set and enqueue it
            vertices.get(node).forEach( neighbor -> {
                if(!visited.contains(neighbor))  queue.add(neighbor);
            });
        }
        return bfs;
    }
}
