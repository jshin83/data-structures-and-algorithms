/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Data.Structures;

import java.util.ArrayList;
import java.util.List;

public class LinkedList {
    Node head;
    private Node tail;
    private static int size;

    public LinkedList() {
        size = 0;
    }

    private static class Node {
        private Object data;
        private Node next;

        private Node(Object data, Node next)
        {
            this.data = data;
            this.next = next;
        }
    }

    /**
     * Takes any value as an argument
     * and adds a new node with that value
     * to the head of the list with an O(1) Time performance
     * @param data int value to insert in new node
     */
     void insert(Object data) {
        Node newNode;

        if(head == null) {
            newNode = new Node(data, null);
            head = newNode;
            tail = newNode;
        } else {
            newNode = new Node(data, head);
            head = newNode;
        }
        size++;
    }

    /**
     * Takes any value as an argument
     * and returns a boolean result depending
     * on whether that value exists
     * as a Node’s value somewhere within the list.
     * @param searchValue int to search for
     * @return boolean true if value is found, else false
     */
     boolean includes(Object searchValue) {
        Node current = head;
        while(current != null) {
            if(current.data.equals(searchValue)) {
                return true;
            }
            current = current.next;
        }

        return false;
    }

    /**
     * Takes in no arguments
     * and returns a collection
     * of the current Node values in the Linked List.
     * @return list of all values in linked list
     */
     List<Object> print() {
        List<Object> nodeList = new ArrayList<>();

        Node current = head;

        while (current != null) {
            nodeList.add(current.data);
            current = current.next;
        }

        return nodeList;
    }

    /**
     * Adds a new node with the given value to the end of the list.
     * @param value value for Node to be inserted at end
     */
    void append(Object value) {
        if(head == null) {
            insert(value);
        } else  {
            Node newNode = new Node(value, null);
            tail.next = newNode;
            tail = newNode;
            size++;
        }
    }

    /**
     * Add a new node with the given newValue
     * immediately before the search value node.
     * @param searchValue value to look for in list
     * @param newValue value to insert as new Node data
     */
    void insertBefore(Object searchValue, Object newValue) {

        if (head != null) {
            if (size == 1 && head.data.equals(searchValue)) {
                insert(newValue);
                return;
            } else {
                Node newNode;
                Node current = head;

                while (current.next != null) {
                    if (current.next.data.equals(searchValue)) {
                        newNode = new Node(newValue, current.next);
                        current.next = newNode;
                        size++;
                        return;
                    }
                    current = current.next;
                }
                //check if last element in list is the search value
                if (tail.data.equals(searchValue)) {
                    newNode = new Node(newValue, tail);
                    current.next = newNode;
                    size++;
                    return;
                }
            }
        }
        // search value doesn't exist in list
        throw new IllegalArgumentException("Element does not exist");
    }

    /**
     * Add a new node with the given newValue
     * immediately after the search value node.
     * @param searchValue value to search for in linked list
     * @param newValue value to insert as new Node data
     */
    void insertAfter(Object searchValue, Object newValue) {

        Node newNode;
        if (head == null) {
            throw new IllegalArgumentException("List is empty");
        }
        if (size == 1 && head.data.equals(searchValue)) {
            newNode = new Node(newValue, null);
            tail.next = newNode;
            tail = newNode;
            size++;
            return;
        }
        Node current = head;
        while (current != null) {
            if (current.data.equals(searchValue)) {
                current.next = new Node(newValue, current.next);
                size++;
                return;
            }
            current = current.next;
        }

        //search value doesn't exist
        throw new IllegalArgumentException("Element does not exist");
    }

    /**
     * Takes a number, k, as a parameter.
     * Return the node’s value that is k from the end of the linked list
     * @param k value from the end of linked list
     * @return Object value at the kth node from the end of the linked list
     */
    Object kthValueFromEnd(int k) {
        if(head == null) {
            throw new NullPointerException("Linked list is empty");
        }
        if(k == 0) {
            return tail.data;
        }
        if(k > size || k < 0) {
            throw new IllegalArgumentException("The number is out of bounds");
        }
        int count = 0;
        Node current = head;
        while(count != (size - k)) {
            current = current.next;
            count++;
        }
        return current.data;
    }

    /**
     * Take in two linked lists, merge them with
     * alternating nodes from each list, and return
     * one linked list.
     * @param one linked list
     * @param two linked list
     * @return linked list
     */
    public static LinkedList mergeLists(LinkedList one, LinkedList two) {
        if(one.head == null && two.head == null) {
            throw new IllegalArgumentException("Both input lists are empty");
        }
        if(one.head == null) {
            return two;
        }
        if(two.head == null) {
            return one;
        }
        if(one.getSize() == 1 && two.getSize() == 1) {
            one.head.next = two.head;
            return one;
        }

        Node current1 = one.head;
        Node current2 = two.head;

        while(current1.next != null && current2.next != null) {
            Node tracker1 = current1.next;
            Node tracker2 = current2.next;

            //connect first to second
            current1.next = current2;
            current2.next = tracker1;

            //move current to next node to do above steps again
            current1 = tracker1;
            current2 = tracker2;
        }

        if(current1.next == null) {
            current1.next = current2;
        }
        if(current2.next == null) {
            current2.next = current1.next;
            current1.next = current2;
        }


        return one;

    }

    /**
     * Getter for head data
     * @return value of head element
     */
     Object getHeadData() {
        return this.head.data;
    }

    /**
     * Getter for size of linked list.
     * @return int how many elements are in list
     */
     int getSize() {
        return size;
    }

    /**
     * Getter for tail data.
     * @return data for last element of list
     */
    Object getTailData() {
         return this.tail.data;
    }

}
