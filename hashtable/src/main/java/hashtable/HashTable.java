/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hashtable;

import java.util.Objects;

public class HashTable<K, V> {

    public static void main(String[] args) {
        HashTable<String, String> demo = new HashTable<>();
        demo.add("hello", "world");
        demo.add("yikes", null);
        demo.add("hello", "world!!!");
        System.out.println(demo.contains("hello"));
        demo.delete("yikes");
        demo.print();
    }
    private final double RESET_LOAD = .75;
    private final int INITIAL_ARRAY_LENGTH = 12;
    private int size;
    private Node[] table;

    public HashTable() {
        table = (Node[])new HashTable.Node[INITIAL_ARRAY_LENGTH];
        size = 0;
    }

    /**
     * Adds new Node.
     * Takes in both the key and value.
     * This method hashes the key, and
     * adds the key and value pair to the table,
     * handling collisions as needed.
     * Does not add null key or null value.
     * @param key Object, data for key
     * @param value Object, data for value
     */
    public void add(K key, V value) {
        if(key == null) {
            throw new IllegalArgumentException("Key cannot be a null value");
        }
        if (value == null && contains(key)) {
            delete(key);
        }
        else {
            if( (size * .75) >= RESET_LOAD) {
                resize();
            }
            Node newNode = new Node(key, value);
            int index = hash(key);
            if(table[index] != null) {
                while(table[index] != null) {
                    //if key is duplicate replace value
                    if(table[index].key.equals(key)) {
                        table[index].value = value;
                        return;
                    }
                    index++;
                }
            }
            table[index] = newNode;
            size++;
        }
    }

    private void resize() {

    }

    public V get(K key) {
        if(key == null) {
            throw new IllegalArgumentException("Table does not store null keys");
        }
        //start at where the key hashes to and look until end or null spot, which means it doesn't exist
        for(int i = hash(key); table[i] != null; i++) {
            if(table[i].key.equals(key)) {
                return table[i].value;
            }
        }
        return null;
    }

    public boolean contains(K key) {
        if(key == null) {
            throw new IllegalArgumentException("Table does not store null keys");
        }
        //start at where the key hashes to and look until end or null spot, which means it doesn't exist
//        for(int i = hash(key); table[i] != null; i++) {
//            if(table[i].equals(key)) {
//                return true;
//            }
//        }
//        return false;
        return get(key) != null;
    }

    public void delete(K key) {
        if(key == null) {
            throw new IllegalArgumentException("Table does not store null keys");
        }
        //look for and find
        for(int i = hash(key); table[i] != null; i++) {
            if(table[i].key.equals(key)) {
                //if found, delete
                table[i] = null;
                size--;
            }
        }
    }


    public int size() {
        return size;
    }

    public void print() {
        for (int i = 0; i < table.length - 1; i++) {
            System.out.printf("%d: ", i);

            Node temp = table[i];
            if(temp != null) {
                System.out.println("(" + temp.key + ", " + temp.value + ")");
            } else {
                System.out.println("Empty");
            }
            System.out.println();


            //this is if I want to implement chaining with array of linked list
//            while (temp != null) {
//                System.out.print("(" + temp.key + ", " + temp.value + ")");
//
//                if (temp.next != null) {
//                    System.out.print(" --> ");
//                }
//                temp = temp.next;
//            }

        }
    }

    private int hash(K key) {
        if (key == null) {
            return -1;
        }
        return Math.abs(key.hashCode() % this.table.length);
        //return Objects.hash(node.key , node.value, this.table.length);
    }

    private class Node {
        K key;
        V value;
        Node next; //in case i want to use chaining

        Node(K key, V value) {
            this.key = key;
            this.value = value;
        }

    }

}
